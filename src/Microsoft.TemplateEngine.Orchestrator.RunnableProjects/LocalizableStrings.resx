<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Authoring_InvalidJsonElementInLocalizationFile" xml:space="preserve">
    <value>Localization file should only contain elements with type 'string'. Remove elements that are not strings.</value>
  </data>
  <data name="Authoring_InvalidManualInstructionLocalizationIndex" xml:space="preserve">
    <value>In localization file under the post action with id '{1}', there are localized strings for manual instruction(s) with ids '{0}'. These manual instructions do not exist in the template.json file and should be removed from localization file.</value>
    <comment>{0} is a list of single-word identifier strings separated by comma. Such as "myManualInstruction, someUserPickedText, instruction3".
{1} is a single-word identifier string. Such as "myPostAction".</comment>
  </data>
  <data name="Authoring_InvalidMultichoiceSymbol" xml:space="preserve">
    <value>Choice parameter {0} is invalid. It allows multiple values ('AllowMultipleValues=true'), while some of the configured choices contain separator characters ({1}). Invalid choices: {2}</value>
    <comment>{0} is the offending symbol name, {1} is a set of separator characters, {2} is a csv list of offending choice values</comment>
  </data>
  <data name="Authoring_InvalidPostActionLocalizationIndex" xml:space="preserve">
    <value>Post action(s) with id(s) '{0}' specified in the localization file do not exist in the template.json file. Remove the localized strings from the localization file.</value>
    <comment>{0} is a list of single-word identifier strings separated by comma. Such as "myManualInstruction, someUserPickedText, instruction3".</comment>
  </data>
  <data name="Authoring_InvalidRegex" xml:space="preserve">
    <value>'{0}' could not be parsed as a regular expression</value>
  </data>
  <data name="Authoring_MalformedPostActionManualInstructions" xml:space="preserve">
    <value>One or more postActions have a malformed or missing manualInstructions value.</value>
  </data>
  <data name="Authoring_ManualInstructionIdIsNotUnique" xml:space="preserve">
    <value>'id' of the manual instruction '{0}' at index {1} is not unique. Only the first manual instruction that uses this id will be localized.</value>
    <comment>{0} is any identifier string that user provided in the file. Such as: "myInstruction", "firstInstruction", "instruction1" etc.
{1} is a whole number representing the zero-based index of the manual instruction. Such as "5", or "0".</comment>
  </data>
  <data name="Authoring_MissingValue" xml:space="preserve">
    <value>Missing '{0}'.</value>
  </data>
  <data name="Authoring_NonBoolDataTypeForRegexMatch" xml:space="preserve">
    <value>A non-bool DataType was specified for a regexMatch type symbol</value>
  </data>
  <data name="Authoring_PostActionIdIsNotUnique" xml:space="preserve">
    <value>[{0}]: id of the post action '{1}' at index '{2}' is not unique. Only the first post action that uses this id will be localized.</value>
    <comment>{0} is any identifier string that user provided in the file. Such as "myPostAction", "firstPostAction", "postAction1" etc.
{1} is a number representing the zero-based index of the post action. Such as "5", or "0".</comment>
  </data>
  <data name="Authoring_PostActionMustHaveActionId" xml:space="preserve">
    <value>[{0}]: Post action at index '{1}' should have an 'actionId' to declare the action to be executed.</value>
    <comment>{0} is a whole number representing the zero-based index of the post action. Such as "5" or "0".
Do not localize: actionId</comment>
  </data>
  <data name="Authoring_SourceDoesNotExist" xml:space="preserve">
    <value>Source '{0}' in template does not exist.</value>
  </data>
  <data name="Authoring_SourceIsOutsideInstallSource" xml:space="preserve">
    <value>Source location '{0}' is outside the specified install source location.</value>
  </data>
  <data name="Authoring_SourceMustBeDirectory" xml:space="preserve">
    <value>Source must be a directory, but '{0}' is a file.</value>
  </data>
  <data name="Authoring_TemplateMissingCommonInformation" xml:space="preserve">
    <value>The template configuration {0} is missing common information:</value>
    <comment>{0} is template configuration location.</comment>
  </data>
  <data name="Authoring_TemplateNotInstalled" xml:space="preserve">
    <value>Failed to load template from {0}:</value>
    <comment>{0} is template configuration location.</comment>
  </data>
  <data name="Authoring_TemplateNotInstalled_Message" xml:space="preserve">
    <value>Failed to load template from {0}.
Details: {1}</value>
    <comment>{0} is template configuration location.</comment>
  </data>
  <data name="Authoring_TemplateRootOutsideInstallSource" xml:space="preserve">
    <value>The template root is outside the specified install source location.</value>
  </data>
  <data name="BindSymbolEvaluator_Warning_EvaluationError" xml:space="preserve">
    <value>Failed to evaluate bind symbol '{0}', it will be skipped.</value>
    <comment>{0} - name of the symbol in configuration that cannot be evaluated</comment>
  </data>
  <data name="BindSymbolEvaluator_Warning_ValueAvailableFromMultipleSources" xml:space="preserve">
    <value>Failed to evaluate binding '{0}', its value is available from multiple sources: {1}. Use the prefixed value ({2}) in template configuration instead.</value>
    <comment>{0} - binding from template.json configuration
{1} - the comma separated list of sources (localized values) which define the binding
{2} - the comma separated list of prefixes that can be used to define the source of the value</comment>
  </data>
  <data name="LocalizationModelDeserializer_Error_FailedToParse" xml:space="preserve">
    <value>Failed to read parse localization file {0}, it will be skipped from further processing.</value>
  </data>
  <data name="RunnableProjectGenerator_CannotAddImplicitChoice" xml:space="preserve">
    <value>Variable [{0}] already added with value [{1}]. Cannot add it as implicit variable with value of self.</value>
    <comment>{0} is the choiceKey, {1} is the existing conflict value</comment>
  </data>
  <data name="RunnableProjectGenerator_Exception_ConfigShouldBeFile" xml:space="preserve">
    <value>Template configuration must be a file, but {0} is not a file.</value>
    <comment>{0} is template configuration location.</comment>
  </data>
  <data name="RunnableProjectGenerator_Exception_LocaleConfigShouldBeFile" xml:space="preserve">
    <value>Template localization configuration must be a file, but {0} is not a file.</value>
    <comment>{0} is template localization configuration location.</comment>
  </data>
  <data name="RunnableProjectGenerator_Exception_TemplateValidationFailed" xml:space="preserve">
    <value>The template configuration {0} is not valid.</value>
    <comment>{0} is template configuration location.</comment>
  </data>
  <data name="RunnableProjectGenerator_Exception_TemplateVersionNotSupported" xml:space="preserve">
    <value>The template is not compatible with generator version: allowed versions: {0}, generator version: {1}.</value>
  </data>
  <data name="RunnableProjectGenerator_Warning_LocFileSkipped" xml:space="preserve">
    <value>Localization file {0} is not compatible with base configuration {1}, and will be skipped.</value>
    <comment>{0} and {1} are template configuration locations.</comment>
  </data>
  <data name="SimpleConfigModel_AuthoringException_MergeConfiguration_FileNotFound" xml:space="preserve">
    <value>Failed to load additional configuration file {0}, the file does not exist.</value>
  </data>
  <data name="SimpleConfigModel_AuthoringException_MergeConfiguration_InvalidFileName" xml:space="preserve">
    <value>Failed to load additional configuration file {0}. Additional configuration file names must end with '.{1}'.</value>
  </data>
  <data name="SimpleConfigModel_Error_Constraints_InvalidSyntax" xml:space="preserve">
    <value>'{0}' should contain objects.</value>
    <comment>{0} is name of JSON property </comment>
  </data>
  <data name="SimpleConfigModel_Error_Constraints_MissingType" xml:space="preserve">
    <value>Constraint definition '{0}' does not contain mandatory property '{1}'.</value>
    <comment>{0} - JSON with constraint defintion, {1} - missing property.</comment>
  </data>
  <data name="SymbolModel_Error_MandatoryPropertyMissing" xml:space="preserve">
    <value>The symbol '{0}' of type '{1}' is incorrect: mandatory property '{2}' is not set. The symbol will be skipped.</value>
  </data>
  <data name="Symbol_Error_IsRequiredNotABool" xml:space="preserve">
    <value>Found disallowed value for IsRequired property: [{0}], expected boolean value.</value>
    <comment>{0} - the json property</comment>
  </data>
  <data name="Symbol_Error_IsRequiredNotABoolOrString" xml:space="preserve">
    <value>Found disallowed value for IsRequired property: [{0}], expected boolean or string (condition) value</value>
    <comment>{0} - the json property</comment>
  </data>
</root>