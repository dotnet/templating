<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="command_export_help_description" xml:space="preserve">
    <value>Given a template.config file, creates a "localize" directory next to it and exports the localization files into the created directory. If the localization files already exist, the existing translations will be preserved.</value>
    <comment>The phrase "localization files" here mean the files that will be given to the translators to be localized.</comment>
  </data>
  <data name="command_export_help_dryrun_description" xml:space="preserve">
    <value>If this option is specified, modified files will not be saved to file system and the changes will only be printed to console output.</value>
  </data>
  <data name="command_export_help_language_description" xml:space="preserve">
    <value>The list of languages to be supported by this template. The following language list will be used as default if this option is omitted: cs, de, en, es, fr, it, ja, ko, pl, pt-BR, ru, tr, zh-Hans, zh-Hant</value>
  </data>
  <data name="command_export_help_recursive_description" xml:space="preserve">
    <value>When specified, subdirectories are also searched for template.json files.</value>
    <comment>Do not localize: "template.json"</comment>
  </data>
  <data name="command_export_help_templatePath_description" xml:space="preserve">
    <value>Specifies the path to the template.json file. If a directory is given, template.json file will be searched within the directory. If --recursive options is specified, all the template.json files under the given directory and its subdirectories will be taken as input.</value>
    <comment>Do not localize: "template.json", "--recursive"</comment>
  </data>
  <data name="command_export_log_cancelled" xml:space="preserve">
    <value>"export" command for the following file was cancelled: "{0}".</value>
    <comment>Do not localize: "export"</comment>
  </data>
  <data name="command_export_log_executionEnded" xml:space="preserve">
    <value>Execution of "export" command has completed. {0} files were processed.</value>
    <comment>{0} is the number of files. Do not localize "export"</comment>
  </data>
  <data name="command_export_log_templateExportFailedWithError" xml:space="preserve">
    <value>Generating localization files for a template.json has failed.
Reason: {0}.
File Path: {1}.</value>
    <comment>{0} is a sentence such as "Json property should contain a field 'ID'"
{1} is a file path such as: C:\temp\template.json
Do not localize: "template.json"</comment>
  </data>
  <data name="command_export_log_templateExportFailedWithException" xml:space="preserve">
    <value>Generating localization files for the following template.json file has failed: "{0}".</value>
  </data>
  <data name="command_export_log_templateExportSucceeded" xml:space="preserve">
    <value>Localization files were successfully generated for the template.json file at path "{0}".</value>
  </data>
  <data name="command_export_log_templateJsonNotFound" xml:space="preserve">
    <value>Failed to find "template.json" file under the path "{0}".</value>
    <comment>Do not localize: "template.json"</comment>
  </data>
  <data name="command_validate_help_description" xml:space="preserve">
    <value>Validates the templates at given location.</value>
  </data>
  <data name="command_validate_help_locationArg_description" xml:space="preserve">
    <value>The location of template(s) to validate.</value>
  </data>
  <data name="command_validate_info_no entries" xml:space="preserve">
    <value>&lt;no entries&gt;</value>
    <comment>used when there is no entries in the list</comment>
  </data>
  <data name="command_validate_info_scanning_completed" xml:space="preserve">
    <value>Location '{0}': found {1} templates.</value>
    <comment>{0} - file path to templates to scan; {1} - count of templates found.</comment>
  </data>
  <data name="command_validate_info_scanning_in_progress" xml:space="preserve">
    <value>Scanning location '{0}' for the templates..</value>
    <comment>{0} - file path to templates to scan</comment>
  </data>
  <data name="command_validate_info_summary_invalid" xml:space="preserve">
    <value>Template {0}: the template is not valid.</value>
    <comment>{0} - template name and identity in format name (identity)</comment>
  </data>
  <data name="command_validate_info_summary_loc_invalid" xml:space="preserve">
    <value>'{0}' localization for the template {1}: the localization file is not valid. The localization will be skipped.</value>
    <comment>{1} - template name and identity in format name (identity), {0} - locale in format en-US</comment>
  </data>
  <data name="command_validate_info_summary_loc_valid" xml:space="preserve">
    <value>'{0}' localization for the template {1}: the localization file is valid.</value>
    <comment>{1} - template name and identity in format name (identity), {0} - locale in format en-US</comment>
  </data>
  <data name="command_validate_info_summary_valid" xml:space="preserve">
    <value>Template {0}: the template is valid.</value>
    <comment>{0} - template name and identity in format name (identity)</comment>
  </data>
  <data name="command_validate_info_template_header" xml:space="preserve">
    <value>Found template {0}:</value>
    <comment>The header is followed by list of issues found in the template. {0} - template name and identity in format name (identity)</comment>
  </data>
  <data name="command_validate_info_template_loc_header" xml:space="preserve">
    <value>Found localization '{0}' for template {1}:</value>
    <comment>The header is followed by list of issues found in the template localization. {1} - template name and identity in format name (identity), {0} - locale in format en-US</comment>
  </data>
  <data name="command_verify_error_failed" xml:space="preserve">
    <value>Verification Failed.</value>
  </data>
  <data name="command_verify_error_unrecognizedArguments" xml:space="preserve">
    <value>Argument(s) {0} are not recognized. Must be one of: {1}.</value>
    <comment>{0} and {1} is both a list of arguments</comment>
  </data>
  <data name="command_verify_help_customExcludes_description" xml:space="preserve">
    <value>Specifies pattern(s) defining files to be excluded from verification.</value>
  </data>
  <data name="command_verify_help_customIncludes_description" xml:space="preserve">
    <value>Specifies pattern(s) defining files to be included to verification (all files are included if not specified).</value>
  </data>
  <data name="command_verify_help_description" xml:space="preserve">
    <value>Runs the template with specified arguments and compares the result with expectations files.</value>
  </data>
  <data name="command_verify_help_disableDefaultExcludes_description" xml:space="preserve">
    <value>If set to true - all template output files will be verified, unless --exclude-pattern option is used.</value>
    <comment>Do not translate 'true'. Do not translate '--exclude-pattern'</comment>
  </data>
  <data name="command_verify_help_disableDiffTool_description" xml:space="preserve">
    <value>If set to true - the diff tool won't be automatically started by the Verifier on verification failures.</value>
    <comment>Do not translate 'true'.</comment>
  </data>
  <data name="command_verify_help_expectFailure_description" xml:space="preserve">
    <value>If set to true - 'dotnet new' command is expected to return non-zero return code.</value>
    <comment>Do not translate 'true'. Do not translate 'dotnet new'</comment>
  </data>
  <data name="command_verify_help_outputPath_description" xml:space="preserve">
    <value>Specifies the path to target directory to output the generated template to.</value>
  </data>
  <data name="command_verify_help_scenarioName_description" xml:space="preserve">
    <value>Specifies optional scenario name to be used in the snapshot folder name.</value>
  </data>
  <data name="command_verify_help_snapshotsDirPath_description" xml:space="preserve">
    <value>Specifies path to the directory with snapshot files.</value>
  </data>
  <data name="command_verify_help_templateName_description" xml:space="preserve">
    <value>Name of the template to be verified. Can be already installed template or a template within local path specified with -p/--template-path option.</value>
    <comment>Do not translate the '-p/--template-path'</comment>
  </data>
  <data name="command_verify_help_templatePath_description" xml:space="preserve">
    <value>Specifies the path to the directory with template to be verified.</value>
  </data>
  <data name="command_verify_help_uniqueFor_description" xml:space="preserve">
    <value>Sets the Verifier expectations directory naming convention, by indicating which scenarios should be differentiated.</value>
  </data>
  <data name="command_verify_help_verifyOutputs_description" xml:space="preserve">
    <value>If set to true - 'dotnet new' command standard output and error contents will be verified along with the produced template files.</value>
    <comment>Do not translate 'true'. Do not translate 'dotnet new'</comment>
  </data>
  <data name="generic_log_commandExecutionFailed" xml:space="preserve">
    <value>"{0}" command has encountered an error. See the logs for more details.</value>
    <comment>{0} will be replaced by the command name. Such as: "export" command has encountered an error.</comment>
  </data>
  <data name="generic_log_commandExecutionFailedWithErrorMessage" xml:space="preserve">
    <value>There was an error while running the "--{0}" command. Error message: "{1}". See the logs for more details.</value>
  </data>
</root>